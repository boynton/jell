(def sort:sorted? (fn (seq less?) (if (null? seq) #t (if (vector? seq) ((fn (n) (if (<= n 1) #t ((fn (system:loop) (set! system:loop (fn (i) (if ((fn (system:tmp) (if system:tmp system:tmp (less? (vector-ref seq (- i 1)) (vector-ref seq i)))) (= i n)) (= i n) (system:loop (+ i 1))))) (system:loop 1)) #f))) (vector-length seq)) ((fn (loop) (set! loop (fn (last next) ((fn (system:tmp) (if system:tmp system:tmp (if (not (less? (car next) last)) (loop (car next) (cdr next)) #f))) (null? next)))) (loop (car seq) (cdr seq))) #f)))))
(def sort:merge (fn (a b less?) (if (null? a) b (if (null? b) a ((fn (loop) (set! loop (fn (x a y b) (if (less? y x) (if (null? b) (cons y (cons x a)) (cons y (loop x a (car b) (cdr b)))) (if (null? a) (cons x (cons y b)) (cons x (loop (car a) (cdr a) y b)))))) (loop (car a) (cdr a) (car b) (cdr b))) #f)))))
(def sort:merge! (fn (a b less?) ((fn (loop) (set! loop (fn (r a b) (if (less? (car b) (car a)) (begin (set-cdr! r b) (if (null? (cdr b)) (set-cdr! b a) (loop b a (cdr b)))) (begin (set-cdr! r a) (if (null? (cdr a)) (set-cdr! a b) (loop a (cdr a) b)))))) (if (null? a) b (if (null? b) a (if (less? (car b) (car a)) (begin (if (null? (cdr b)) (set-cdr! b a) (loop b a (cdr b))) b) (begin (if (null? (cdr a)) (set-cdr! a b) (loop a (cdr a) b)) a))))) #f)))
(def sort:sort! (fn (seq less?) ((fn (step) (set! step (fn (n) (if (> n 2) ((fn (j) ((fn (a) ((fn (k) ((fn (b) (sort:merge! a b less?)) (step k))) (- n j))) (step j))) (quotient n 2)) (if (= n 2) ((fn (x y p) (set! seq (cdr (cdr seq))) (if (less? y x) (begin (set-car! p y) (set-car! (cdr p) x)) #f) (set-cdr! (cdr p) '()) p) (car seq) (car (cdr seq)) seq) (if (= n 1) ((fn (p) (set! seq (cdr seq)) (set-cdr! p '()) p) seq) '()))))) (if (vector? seq) ((fn (n) (set! seq (vector->list seq)) ((fn (system:loop) (set! system:loop (fn (i p) (if (null? p) vector (begin (vector-set! vector i (car p)) (system:loop (+ i 1) (cdr p)))))) (system:loop 0 (step n))) #f)) (vector-length seq)) (step (length seq)))) #f)))
(def sort:sort (fn (seq less?) (if (vector? seq) (list->vector (sort:sort! (vector->list seq) less?)) (sort:sort! (append seq '()) less?))))
(def sorted? sort:sorted?)
(def merge sort:merge)
(def merge! sort:merge!)
(def sort sort:sort)
(def sort! sort:sort!)

(def pi (fn (n d) (set! n (+ (quotient n d) 1)) ((fn (m) ((fn (r a) (vector-set! a m 4) ((fn (system:loop) (set! system:loop (fn (b q j) (if (> j n) #f (begin (begin ((fn (system:loop) (set! system:loop (fn (k) (if (zero? k) #f (begin (begin (set! q (+ q (* (vector-ref a k) r))) ((fn (t) (vector-set! a k (remainder q t)) (set! q (* k (quotient q t)))) (+ 1 (* 2 k)))) (system:loop (- k 1)))))) (system:loop m)) #f) ((fn (s) ((fn (system:loop) (set! system:loop (fn (l) (if (>= l d) (display s) (begin (display #\0) (system:loop (+ 1 l)))))) (system:loop (string-length s))) #f)) (number->string (+ b (quotient q r)))) (display (if (zero? (modulo j 10)) #\newline #\space))) (system:loop (remainder q r) 0 (+ 1 j)))))) (system:loop 2 0 1)) #f) (newline)) ((fn (system:loop) (set! system:loop (fn (i s) (if (>= i d) s (system:loop (+ 1 i) (* 10 s))))) (system:loop 0 1)) #f) (make-vector (+ 1 m) 2))) (quotient (* n (* d 3322)) 1000))))

(def make-foo (fn(n) ((fn (system:loop) (set! system:loop (fn (l i) (if (>= i n) l (system:loop (cons i l) (+ i 1))))) (system:loop '() 0)) #f)))

(def benchmark (fn () ((fn (foo) (sort foo <) (sort foo >) (set! foo '()) (pi 1000 5)) (make-foo 100000))))
(benchmark)
(benchmark)
(benchmark)
(benchmark)
(benchmark)
(nil true false '(1 2)) (fn (x) (+ 1 2) (quote foo)
(import :foo)